How to Transform Target Variables for Regression in Python
https://machinelearningmastery.com/how-to-transform-target-variables-for-regression-with-scikit-learn/
2019-12-15
Data preparation is a big part of applied machine learning.
Correctly preparing your training data can mean the difference between mediocre and extraordinary results, even with very simple linear algorithms.
Performing data preparation operations, such as scaling, is relatively straightforward for input variables and has been made routine in Python via the Pipeline scikit-learn class.
On regression predictive modeling problems where a numerical value must be predicted, it can also be critical to scale and perform other data transformations on the target variable. This can be achieved in Python using the TransformedTargetRegressor class.
In this tutorial, you will discover how to use the TransformedTargetRegressor to scale and transform target variables for regression using the scikit-learn Python machine learning library.
After completing this tutorial, you will know:
- The importance of scaling input and target data for machine learning.
- The two approaches to applying data transforms to target variables.
- How to use the TransformedTargetRegressor on a real regression dataset.
Kick-start your project with my new book Data Preparation for Machine Learning, including step-by-step tutorials and the Python source code files for all examples.
Let’s get started.
How to Transform Target Variables for Regression With Scikit-LearnPhoto by Don Henise, some rights reserved.
# Tutorial Overview
This tutorial is divided into three parts; they are:
- Importance of Data Scaling
- How to Scale Target Variables
- Example of Using the TransformedTargetRegressor
# Importance of Data Scaling
It is common to have data where the scale of values differs from variable to variable.
For example, one variable may be in feet, another in meters, and so on.
Some machine learning algorithms perform much better if all of the variables are scaled to the same range, such as scaling all variables to values between 0 and 1, called normalization.
This effects algorithms that use a weighted sum of the input, like linear models and neural networks, as well as models that use distance measures such as support vector machines and k-nearest neighbors.
As such, it is a good practice to scale input data, and perhaps even try other data transforms such as making the data more normal (better fit a Gaussian probability distribution) using a power transform.
This also applies to output variables, called target variables, such as numerical values that are predicted when modeling regression predictive modeling problems.
For regression problems, it is often desirable to scale or transform both the input and the target variables.
Scaling input variables is straightforward. In scikit-learn, you can use the scale objects manually, or the more convenient Pipeline that allows you to chain a series of data transform objects together before using your model.
The Pipeline will fit the scale objects on the training data for you and apply the transform to new data, such as when using a model to make a prediction.
For example:
The challenge is, what is the equivalent mechanism to scale target variables in scikit-learn?




# How to Scale Target Variables
There are two ways that you can scale target variables.
The first is to manually manage the transform, and the second is to use a new automatic way for managing the transform.
- Manually transform the target variable.
- Automatically transform the target variable.
Manually managing the scaling of the target variable involves creating and applying the scaling object to the data manually.
It involves the following steps:
- Create the transform object, e.g. a MinMaxScaler.
- Fit the transform on the training dataset.
- Apply the transform to the train and test datasets.
- Invert the transform on any predictions made.
For example, if we wanted to normalize a target variable, we would first define and train a MinMaxScaler object:
We would then transform the train and test target variable data.
Then we would fit our model and use the model to make predictions.
Before the predictions can be used or evaluated with an error metric, we would have to invert the transform.
This is a pain, as it means you cannot use convenience functions in scikit-learn, such as cross_val_score(), to quickly evaluate a model.
An alternate approach is to automatically manage the transform and inverse transform.
This can be achieved by using the TransformedTargetRegressor object that wraps a given model and a scaling object.
It will prepare the transform of the target variable using the same training data used to fit the model, then apply that inverse transform on any new data provided when calling predict(), returning predictions in the correct scale.
To use the TransformedTargetRegressor, it is defined by specifying the model and the transform object to use on the target; for example:
Later, the TransformedTargetRegressor instance can be fit like any other model by calling the fit() function and used to make predictions by calling the predict() function.
This is much easier and allows you to use helpful functions like cross_val_score() to evaluate a model
Now that we are familiar with the TransformedTargetRegressor, let’s look at an example of using it on a real dataset.
# Example of Using the TransformedTargetRegressor
In this section, we will demonstrate how to use the TransformedTargetRegressor on a real dataset.
We will use the Boston housing regression problem that has 13 inputs and one numerical target and requires learning the relationship between suburb characteristics and house prices.
The dataset can be downloaded from here:
- Boston Housing Dataset (housing.csv)
Download the dataset and save it in your current working directory with the name “housing.csv“.
Looking in the dataset, you should see that all variables are numeric.
You can learn more about this dataset and the meanings of the columns here:
- Boston Housing Data Details (housing.names)
We can confirm that the dataset can be loaded correctly as a NumPy array and split it into input and output variables.
The complete example is listed below.
Running the example prints the shape of the input and output parts of the dataset, showing 13 input variables, one output variable, and 506 rows of data.
We can now prepare an example of using the TransformedTargetRegressor.
A naive regression model that predicts the mean value of the target on this problem can achieve a mean absolute error (MAE) of about 6.659. We will aim to do better.
In this example, we will fit a HuberRegressor object and normalize the input variables using a Pipeline.
Next, we will define a TransformedTargetRegressor instance and set the regressor to the pipeline and the transformer to an instance of a MinMaxScaler object.
We can then evaluate the model with normalization of the input and output variables using 10-fold cross-validation.
Tying this all together, the complete example is listed below.
Running the example evaluates the model with normalization of the input and output variables.
Note: Your results may vary given the stochastic nature of the algorithm or evaluation procedure, or differences in numerical precision. Consider running the example a few times and compare the average outcome.
In this case, we achieve a MAE of about 3.1, much better than a naive model that achieved about 6.6.
We are not restricted to using scaling objects; for example, we can also explore using other data transforms on the target variable, such as the PowerTransformer, that can make each variable more-Gaussian-like (using the Yeo-Johnson transform) and improve the performance of linear models.
By default, the PowerTransformer also performs a standardization of each variable after performing the transform.
The complete example of using a PowerTransformer on the input and target variables of the housing dataset is listed below.
Running the example evaluates the model with a power transform of the input and output variables.
Note: Your results may vary given the stochastic nature of the algorithm or evaluation procedure, or differences in numerical precision. Consider running the example a few times and compare the average outcome.
In this case, we see further improvement to a MAE of about 2.9.

# Further Reading
This section provides more resources on the topic if you are looking to go deeper.
- Transforming target in regression scikit-learn API.
- sklearn.compose.TransformedTargetRegressor API.
- sklearn.preprocessing.MinMaxScaler API.
- sklearn.preprocessing.PowerTransformer API.
- Boston Housing Dataset (housing.csv)
- Boston Housing Data Details (housing.names)
# Summary
In this tutorial, you discovered how to use the TransformedTargetRegressor to scale and transform target variables for regression in scikit-learn.
Specifically, you learned:
- The importance of scaling input and target data for machine learning.
- The two approaches to applying data transforms to target variables.
- How to use the TransformedTargetRegressor on a real regression dataset.
Do you have any questions?
Ask your questions in the comments below and I will do my best to answer.
# Get a Handle on Modern Data Preparation!
...with just a few lines of python code
Discover how in my new Ebook:
Data Preparation for Machine Learning
It provides self-study tutorials with full working code on:
Feature Selection, RFE, Data Cleaning, Data Transforms, Scaling, Dimensionality Reduction,
and much more...
See What's Inside

'''

# prepare the model with input scaling
pipeline = Pipeline(steps=[('normalize', MinMaxScaler()), ('model', LinearRegression())])
# fit pipeline
pipeline.fit(train_x, train_y)
# make predictions
yhat = pipeline.predict(test_x)

# create target scaler object
target_scaler = MinMaxScaler()
target_scaler.fit(train_y)

# transform target variables
train_y = target_scaler.transform(train_y)
test_y = target_scaler.transform(test_y)

# invert transform on predictions
yhat = model.predict(test_X)
yhat = target_scaler.inverse_transform(yhat)

# define the target transform wrapper
wrapped_model = TransformedTargetRegressor(regressor=model, transformer=MinMaxScaler())

# use the target transform wrapper
wrapped_model.fit(train_X, train_y)
yhat = wrapped_model.predict(test_X)
0.00632,18.00,2.310,0,0.5380,6.5750,65.20,4.0900,1,296.0,15.30,396.90,4.98,24.00
0.02731,0.00,7.070,0,0.4690,6.4210,78.90,4.9671,2,242.0,17.80,396.90,9.14,21.60
0.02729,0.00,7.070,0,0.4690,7.1850,61.10,4.9671,2,242.0,17.80,392.83,4.03,34.70
0.03237,0.00,2.180,0,0.4580,6.9980,45.80,6.0622,3,222.0,18.70,394.63,2.94,33.40
0.06905,0.00,2.180,0,0.4580,7.1470,54.20,6.0622,3,222.0,18.70,396.90,5.33,36.20
...
# load and summarize the dataset
from numpy import loadtxt
# load data
dataset = loadtxt('housing.csv', delimiter=",")
# split into inputs and outputs
X, y = dataset[:, :-1], dataset[:, -1]
# summarize dataset
print(X.shape, y.shape)
(506, 13) (506,)

# prepare the model with input scaling
pipeline = Pipeline(steps=[('normalize', MinMaxScaler()), ('model', HuberRegressor())])

# prepare the model with target scaling
model = TransformedTargetRegressor(regressor=pipeline, transformer=MinMaxScaler())

# evaluate model
cv = KFold(n_splits=10, shuffle=True, random_state=1)
scores = cross_val_score(model, X, y, scoring='neg_mean_absolute_error', cv=cv, n_jobs=-1)
# example of normalizing input and output variables for regression.
from numpy import mean
from numpy import absolute
from numpy import loadtxt
from sklearn.model_selection import cross_val_score
from sklearn.model_selection import KFold
from sklearn.pipeline import Pipeline
from sklearn.linear_model import HuberRegressor
from sklearn.preprocessing import MinMaxScaler
from sklearn.compose import TransformedTargetRegressor
# load data
dataset = loadtxt('housing.csv', delimiter=",")
# split into inputs and outputs
X, y = dataset[:, :-1], dataset[:, -1]
# prepare the model with input scaling
pipeline = Pipeline(steps=[('normalize', MinMaxScaler()), ('model', HuberRegressor())])
# prepare the model with target scaling
model = TransformedTargetRegressor(regressor=pipeline, transformer=MinMaxScaler())
# evaluate model
cv = KFold(n_splits=10, shuffle=True, random_state=1)
scores = cross_val_score(model, X, y, scoring='neg_mean_absolute_error', cv=cv, n_jobs=-1)
# convert scores to positive
scores = absolute(scores)
# summarize the result
s_mean = mean(scores)
print('Mean MAE: %.3f' % (s_mean))
Mean MAE: 3.191
# example of power transform input and output variables for regression.
from numpy import mean
from numpy import absolute
from numpy import loadtxt
from sklearn.model_selection import cross_val_score
from sklearn.model_selection import KFold
from sklearn.pipeline import Pipeline
from sklearn.linear_model import HuberRegressor
from sklearn.preprocessing import PowerTransformer
from sklearn.compose import TransformedTargetRegressor
# load data
dataset = loadtxt('housing.csv', delimiter=",")
# split into inputs and outputs
X, y = dataset[:, :-1], dataset[:, -1]
# prepare the model with input scaling
pipeline = Pipeline(steps=[('power', PowerTransformer()), ('model', HuberRegressor())])
# prepare the model with target scaling
model = TransformedTargetRegressor(regressor=pipeline, transformer=PowerTransformer())
# evaluate model
cv = KFold(n_splits=10, shuffle=True, random_state=1)
scores = cross_val_score(model, X, y, scoring='neg_mean_absolute_error', cv=cv, n_jobs=-1)
# convert scores to positive
scores = absolute(scores)
# summarize the result
s_mean = mean(scores)
print('Mean MAE: %.3f' % (s_mean))
Mean MAE: 2.926
'''
