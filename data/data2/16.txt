Gentle Introduction to Eigenvalues and Eigenvectors for Machine Learning
https://machinelearningmastery.com/introduction-to-eigendecomposition-eigenvalues-and-eigenvectors/
2018-02-18
Matrix decompositions are a useful tool for reducing a matrix to their constituent parts in order to simplify a range of more complex operations.
Perhaps the most used type of matrix decomposition is the eigendecomposition that decomposes a matrix into eigenvectors and eigenvalues. This decomposition also plays a role in methods used in machine learning, such as in the the Principal Component Analysis method or PCA.
In this tutorial, you will discover the eigendecomposition, eigenvectors, and eigenvalues in linear algebra.
After completing this tutorial, you will know:
- What an eigendecomposition is and the role of eigenvectors and eigenvalues.
- How to calculate an eigendecomposition in Python with NumPy.
- How to confirm a vector is an eigenvector and how to reconstruct a matrix from eigenvectors and eigenvalues.
Kick-start your project with my new book Linear Algebra for Machine Learning, including step-by-step tutorials and the Python source code files for all examples.
Let’s get started.
Gentle Introduction to Eigendecomposition, Eigenvalues, and Eigenvectors for Machine LearningPhoto by Mathias Appel, some rights reserved.
# Tutorial Overview
This tutorial is divided into 5 parts; they are:
- Eigendecomposition of a Matrix
- Eigenvectors and Eigenvalues
- Calculation of Eigendecomposition
- Confirm an Eigenvector and Eigenvalue
- Reconstruct Original Matrix




# Eigendecomposition of a Matrix
Eigendecomposition of a matrix is a type of decomposition that involves decomposing a square matrix into a set of eigenvectors and eigenvalues.
One of the most widely used kinds of matrix decomposition is called eigendecomposition, in which we decompose a matrix into a set of eigenvectors and eigenvalues.
— Page 42, Deep Learning, 2016.
A vector is an eigenvector of a matrix if it satisfies the following equation.
This is called the eigenvalue equation, where A is the parent square matrix that we are decomposing, v is the eigenvector of the matrix, and lambda is the lowercase Greek letter and represents the eigenvalue scalar.
Or without the dot notation.
A matrix could have one eigenvector and eigenvalue for each dimension of the parent matrix. Not all square matrices can be decomposed into eigenvectors and eigenvalues, and some can only be decomposed in a way that requires complex numbers. The parent matrix can be shown to be a product of the eigenvectors and eigenvalues.
Or, without the dot notation.
Where Q is a matrix comprised of the eigenvectors, diag(V) is a diagonal matrix comprised of the eigenvalues along the diagonal (sometimes represented with a capital lambda), and Q^-1 is the inverse of the matrix comprised of the eigenvectors.
However, we often want to decompose matrices into their eigenvalues and eigenvectors. Doing so can help us to analyze certain properties of the matrix, much as decomposing an integer into its prime factors can help us understand the behavior of that integer.
— Page 43, Deep Learning, 2016.
Eigen is not a name, e.g. the method is not named after “Eigen”; eigen (pronounced eye-gan) is a German word that means “own” or “innate”, as in belonging to the parent matrix.
A decomposition operation does not result in a compression of the matrix; instead, it breaks it down into constituent parts to make certain operations on the matrix easier to perform. Like other matrix decomposition methods, Eigendecomposition is used as an element to simplify the calculation of other more complex matrix operations.
Almost all vectors change direction, when they are multiplied by A. Certain exceptional vectors x are in the same direction as Ax. Those are the “eigenvectors”. Multiply an eigenvector by A, and the vector Ax is the number lambda times the original x. […] The eigenvalue lambda tells whether the special vector x is stretched or shrunk or reversed or left unchanged – when it is multiplied by A.
— Page 289, Introduction to Linear Algebra, Fifth Edition, 2016.
Eigendecomposition can also be used to calculate the principal components of a matrix in the Principal Component Analysis method or PCA that can be used to reduce the dimensionality of data in machine learning.
# Eigenvectors and Eigenvalues
Eigenvectors are unit vectors, which means that their length or magnitude is equal to 1.0. They are often referred as right vectors, which simply means a column vector (as opposed to a row vector or a left vector). A right-vector is a vector as we understand them.
Eigenvalues are coefficients applied to eigenvectors that give the vectors their length or magnitude. For example, a negative eigenvalue may reverse the direction of the eigenvector as part of scaling it.
A matrix that has only positive eigenvalues is referred to as a positive definite matrix, whereas if the eigenvalues are all negative, it is referred to as a negative definite matrix.
Decomposing a matrix in terms of its eigenvalues and its eigenvectors gives valuable insights into the properties of the matrix. Certain matrix calculations, like computing the power of the matrix, become much easier when we use the eigendecomposition of the matrix.
— Page 262, No Bullshit Guide To Linear Algebra, 2017
# Calculation of Eigendecomposition
An eigendecomposition is calculated on a square matrix using an efficient iterative algorithm, of which we will not go into the details.
Often an eigenvalue is found first, then an eigenvector is found to solve the equation as a set of coefficients.
The eigendecomposition can be calculated in NumPy using the eig() function.
The example below first defines a 3×3 square matrix. The eigendecomposition is calculated on the matrix returning the eigenvalues and eigenvectors.
Running the example first prints the defined matrix, followed by the eigenvalues and the eigenvectors. More specifically, the eigenvectors are the right-hand side eigenvectors and are normalized to unit length.

# Confirm an Eigenvector and Eigenvalue
We can confirm that a vector is indeed an eigenvector of a matrix.
We do this by multiplying the candidate eigenvector by the eigenvector and comparing the result with the eigenvalue.
First, we will define a matrix, then calculate the eigenvalues and eigenvectors. We will then test whether the first vector and value are in fact an eigenvalue and eigenvector for the matrix. We know they are, but it is a good exercise.
The eigenvectors are returned as a matrix with the same dimensions as the parent matrix, where each column is an eigenvector, e.g. the first eigenvector is vectors[:, 0]. Eigenvalues are returned as a list, where value indices in the returned array are paired with eigenvectors by column index, e.g. the first eigenvalue at values[0] is paired with the first eigenvector at vectors[:, 0].
The example multiplies the original matrix with the first eigenvector and compares it to the first eigenvector multiplied by the first eigenvalue.
Running the example prints the results of these two multiplications that show the same resulting vector, as we would expect.

# Reconstruct Original Matrix
We can reverse the process and reconstruct the original matrix given only the eigenvectors and eigenvalues.
First, the list of eigenvectors must be converted into a matrix, where each vector becomes a row. The eigenvalues need to be arranged into a diagonal matrix. The NumPy diag() function can be used for this.
Next, we need to calculate the inverse of the eigenvector matrix, which we can achieve with the inv() NumPy function. Finally, these elements need to be multiplied together with the dot() function.
The example calculates the eigenvalues and eigenvectors again and uses them to reconstruct the original matrix.
Running the example first prints the original matrix, then the matrix reconstructed from eigenvalues and eigenvectors matching the original matrix.

# Extensions
This section lists some ideas for extending the tutorial that you may wish to explore.
- Create 5 examples using each operation with your own data.
- Implement each matrix operation manually for matrices defined as lists of lists.
- Search machine learning papers and find 1 example of each operation being used.
If you explore any of these extensions, I’d love to know.
# Further Reading
This section provides more resources on the topic if you are looking to go deeper.
- Section 6.1 Eigenvalues and eigenvectors. No Bullshit Guide To Linear Algebra, 2017.
- Chapter 6 Eigenvalues and Eigenvectors, Introduction to Linear Algebra, Fifth Edition, 2016.
- Section 2.7 Eigendecomposition, Deep Learning, 2016.
- Chapter 5 Eigenvalues, Eigenvectors, and Invariant Subspaces, Linear Algebra Done Right, Third Edition, 2015.
- Lecture 24, Eigenvalue Problems, Numerical Linear Algebra, 1997.
- numpy.linalg.eig() API
- numpy.diag() API
- numpy.dot() API
- numpy.linalg.inv() API
- eigen on Wiktionary
- Eigenvalues and eigenvectors
- Eigendecomposition of a matrix
- Eigenvalue algorithm
- Matrix decomposition
# Summary
In this tutorial, you discovered the eigendecomposition, eigenvectors, and eigenvalues in linear algebra.
Specifically, you learned:
- What an eigendecomposition is and the role of eigenvectors and eigenvalues.
- How to calculate an eigendecomposition in Python with NumPy.
- How to confirm a vector is an eigenvector and how to reconstruct a matrix from eigenvectors and eigenvalues.
Do you have any questions?
Ask your questions in the comments below and I will do my best to answer.
# Get a Handle on Linear Algebra for Machine Learning!
...by writing lines of code in python
Discover how in my new Ebook:
Linear Algebra for Machine Learning
It provides self-study tutorials on topics like:
Vector Norms, Matrix Multiplication, Tensors, Eigendecomposition, SVD, PCA and much more...
Skip the Academics. Just Results.
See What's Inside

'''
A . v = lambda . v
Av = lambdav
A = Q . diag(V) . Q^-1
A = Qdiag(V)Q^-1
# eigendecomposition
from numpy import array
from numpy.linalg import eig
# define matrix
A = array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
print(A)
# calculate eigendecomposition
values, vectors = eig(A)
print(values)
print(vectors)
[[1 2 3]
 [4 5 6]
 [7 8 9]]

[  1.61168440e+01  -1.11684397e+00  -9.75918483e-16]

[[-0.23197069 -0.78583024  0.40824829]
 [-0.52532209 -0.08675134 -0.81649658]
 [-0.8186735   0.61232756  0.40824829]]
# confirm eigenvector
from numpy import array
from numpy.linalg import eig
# define matrix
A = array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
# calculate eigendecomposition
values, vectors = eig(A)
# confirm first eigenvector
B = A.dot(vectors[:, 0])
print(B)
C = vectors[:, 0] * values[0]
print(C)
[ -3.73863537  -8.46653421 -13.19443305]

[ -3.73863537  -8.46653421 -13.19443305]
# reconstruct matrix
from numpy import diag
from numpy import dot
from numpy.linalg import inv
from numpy import array
from numpy.linalg import eig
# define matrix
A = array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
print(A)
# calculate eigenvectors and eigenvalues
values, vectors = eig(A)
# create matrix from eigenvectors
Q = vectors
# create inverse of eigenvectors matrix
R = inv(Q)
# create diagonal matrix from eigenvalues
L = diag(values)
# reconstruct the original matrix
B = Q.dot(L).dot(R)
print(B)
[[1 2 3]
 [4 5 6]
 [7 8 9]]

[[ 1.  2.  3.]
 [ 4.  5.  6.]
 [ 7.  8.  9.]]
'''
